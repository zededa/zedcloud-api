// Copyright (c) 2018-2021 Zededa, Inc.\n// SPDX-License-Identifier: Apache-2.0\n
// Code generated by go-swagger; DO NOT EDIT.

package swagger_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// ConfigBondMode A bonding mode specifies the policy indicating how bonding slaves are used
// during network transmission.
//
//   - BOND_MODE_UNSPECIFIED: BOND_MODE_UNSPECIFIED : if bonding mode is not explicitly specified,
//
// then by default Round-Robin policy is applied (BOND_MODE_BALANCE_RR).
//   - BOND_MODE_BALANCE_RR: BOND_MODE_BALANCE_RR : transmit packets in sequential order from the first
//
// available slave through the last. This mode provides load balancing
// and fault tolerance.
// This is the default bonding mode.
//   - BOND_MODE_ACTIVE_BACKUP: BOND_MODE_ACTIVE_BACKUP : only one slave in the bond is active.
//
// A different slave becomes active if, and only if, the active slave fails.
// The bond's MAC address is externally visible on only one port to avoid
// confusing the switch.
// This mode provides fault tolerance.
//   - BOND_MODE_BALANCE_XOR: BOND_MODE_BALANCE_XOR : packet source and destination MAC addresses are
//
// used to calculate hash and select the output slave interface accordingly.
// This algorithm will place all traffic destined to a particular network
// peer on the same slave.
// This mode provides load balancing and fault tolerance.
//   - BOND_MODE_BROADCAST: BOND_MODE_BROADCAST: transmits everything on all slave interfaces.
//
// This mode provides fault tolerance.
//   - BOND_MODE_802_3AD: BOND_MODE_802_3AD : IEEE 802.3ad Dynamic link aggregation.
//
// Creates aggregation groups that share the same speed and duplex settings.
// Utilizes all slaves in the active aggregator according to the 802.3ad
// specification.
// Requires that upstream networks equipment supports and has the IEEE 802.3ad
// Dynamic link aggregation properly configured.
//   - BOND_MODE_BALANCE_TLB: BOND_MODE_BALANCE_TLB : adaptive transmit load balancing. Channel bonding that
//
// does not require any special switch support. The outgoing traffic
// is distributed according to the current load (computed relative to the speed)
// on each slave.
// Incoming traffic is received by the current slave. If the receiving slave
// fails, another slave takes over the MAC address of the failed receiving slave.
// This mode provides (TX) load balancing and fault tolerance.
//   - BOND_MODE_BALANCE_ALB: BOND_MODE_BALANCE_ALB : adaptive load balancing. Includes BOND_MODE_BALANCE_TLB
//
// plus receive load balancing (RLB) for IPV4 traffic, and does not require
// any special switch support. The receive load balancing is achieved by ARP
// negotiation.
// This mode provides load balancing and fault tolerance.
//
// swagger:model configBondMode
type ConfigBondMode string

func NewConfigBondMode(value ConfigBondMode) *ConfigBondMode {
	return &value
}

// Pointer returns a pointer to a freshly-allocated ConfigBondMode.
func (m ConfigBondMode) Pointer() *ConfigBondMode {
	return &m
}

const (

	// ConfigBondModeBONDMODEUNSPECIFIED captures enum value "BOND_MODE_UNSPECIFIED"
	ConfigBondModeBONDMODEUNSPECIFIED ConfigBondMode = "BOND_MODE_UNSPECIFIED"

	// ConfigBondModeBONDMODEBALANCERR captures enum value "BOND_MODE_BALANCE_RR"
	ConfigBondModeBONDMODEBALANCERR ConfigBondMode = "BOND_MODE_BALANCE_RR"

	// ConfigBondModeBONDMODEACTIVEBACKUP captures enum value "BOND_MODE_ACTIVE_BACKUP"
	ConfigBondModeBONDMODEACTIVEBACKUP ConfigBondMode = "BOND_MODE_ACTIVE_BACKUP"

	// ConfigBondModeBONDMODEBALANCEXOR captures enum value "BOND_MODE_BALANCE_XOR"
	ConfigBondModeBONDMODEBALANCEXOR ConfigBondMode = "BOND_MODE_BALANCE_XOR"

	// ConfigBondModeBONDMODEBROADCAST captures enum value "BOND_MODE_BROADCAST"
	ConfigBondModeBONDMODEBROADCAST ConfigBondMode = "BOND_MODE_BROADCAST"

	// ConfigBondModeBONDMODE8023AD captures enum value "BOND_MODE_802_3AD"
	ConfigBondModeBONDMODE8023AD ConfigBondMode = "BOND_MODE_802_3AD"

	// ConfigBondModeBONDMODEBALANCETLB captures enum value "BOND_MODE_BALANCE_TLB"
	ConfigBondModeBONDMODEBALANCETLB ConfigBondMode = "BOND_MODE_BALANCE_TLB"

	// ConfigBondModeBONDMODEBALANCEALB captures enum value "BOND_MODE_BALANCE_ALB"
	ConfigBondModeBONDMODEBALANCEALB ConfigBondMode = "BOND_MODE_BALANCE_ALB"
)

// for schema
var configBondModeEnum []interface{}

func init() {
	var res []ConfigBondMode
	if err := json.Unmarshal([]byte(`["BOND_MODE_UNSPECIFIED","BOND_MODE_BALANCE_RR","BOND_MODE_ACTIVE_BACKUP","BOND_MODE_BALANCE_XOR","BOND_MODE_BROADCAST","BOND_MODE_802_3AD","BOND_MODE_BALANCE_TLB","BOND_MODE_BALANCE_ALB"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		configBondModeEnum = append(configBondModeEnum, v)
	}
}

func (m ConfigBondMode) validateConfigBondModeEnum(path, location string, value ConfigBondMode) error {
	if err := validate.EnumCase(path, location, value, configBondModeEnum, true); err != nil {
		return err
	}
	return nil
}

// Validate validates this config bond mode
func (m ConfigBondMode) Validate(formats strfmt.Registry) error {
	var res []error

	// value enum
	if err := m.validateConfigBondModeEnum("", "body", m); err != nil {
		return err
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// ContextValidate validates this config bond mode based on context it is used
func (m ConfigBondMode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}
