// Copyright (c) 2018-2021 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

// Code generated by go-swagger; DO NOT EDIT.

package swagger_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ConfigPhysicalIO PhysicalIO:
//    Absolute low level description of physical buses and ports that are
//    available on given platform.
//    Collection of these IOs, constitute what we would call as hardware
//    model. Each physical IO is manageable and visible to EVE software, and
//    it can be further configured to either provide IP connectivity or
//    directly be given to workloads
//
// swagger:model configPhysicalIO
type ConfigPhysicalIO struct {

	// assigngrp
	// Assignment Group, is unique label that is applied across PhysicalIOs
	// EntireGroup can be assigned to application or nothing at all
	//
	// This is the name used in AppInstanceConfig.adapters to assign an
	// adapter to an application.
	//
	// If assigngrp is not set, the Adapter cannot be assigned to any
	// application. One example is, when the adapter is on the same Pci
	// bus as another device required by Dom0.
	//
	// Even if there is only one device on the its PCIBus, the assignGrp Must
	// be set.
	Assigngrp string `json:"assigngrp,omitempty"`

	// physical and logical attributes
	//    For example in WWAN to which firmware version to load etc
	Cbattr map[string]string `json:"cbattr,omitempty"`

	// logicallabel - provides the ability to model designer to refer
	//    the physicalIO port to using more friendly name
	// For example Eth0->Mgmt0
	//  or USBA->ConfigDiskA etc
	Logicallabel string `json:"logicallabel,omitempty"`

	// The hardware bus address. The key to this map can be of the following
	// (case-insensitive) values:
	// "pcilong": the address is a PCI id of the form 0000:02:00.0
	// "ifname": the address is a string for a network interface like "eth1"
	// "serial": the address is a Linux serial port alias such as "/dev/ttyS2"
	// "irq": the address is a number such as "5". This can be a comma
	//    separated list of integers or even a range of integers. Hence using
	//    a string to address this.
	// "ioports": the address is a string such as "2f8-2ff"
	// "usbaddr": the address is a USB of the form of "1:2.3"
	// If the type is PhyIoNet*, then there needs to be an "ifname" physaddr.
	Phyaddrs map[string]string `json:"phyaddrs,omitempty"`

	// physical label typically printed on box.
	// Example Eth0, Eth1, Wifi0, ComA, ComB
	Phylabel string `json:"phylabel,omitempty"`

	// ptype
	Ptype *CommonPhyIoType `json:"ptype,omitempty"`

	// usage - indicates the role of adapter ( mgmt / blocked / app-direct
	//    etc. )
	Usage *CommonPhyIoMemberUsage `json:"usage,omitempty"`

	// usagePolicy - Policy Object used to further refine the usage.
	// For example, specify if this should be only used as fallback?
	//    Or used as the primary uplink? Allow App traffic? restrict
	//    app traffic?? etc..
	UsagePolicy *ConfigPhyIOUsagePolicy `json:"usagePolicy,omitempty"`
}

// Validate validates this config physical i o
func (m *ConfigPhysicalIO) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePtype(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsagePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConfigPhysicalIO) validatePtype(formats strfmt.Registry) error {
	if swag.IsZero(m.Ptype) { // not required
		return nil
	}

	if m.Ptype != nil {
		if err := m.Ptype.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ptype")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ptype")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigPhysicalIO) validateUsage(formats strfmt.Registry) error {
	if swag.IsZero(m.Usage) { // not required
		return nil
	}

	if m.Usage != nil {
		if err := m.Usage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("usage")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("usage")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigPhysicalIO) validateUsagePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.UsagePolicy) { // not required
		return nil
	}

	if m.UsagePolicy != nil {
		if err := m.UsagePolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("usagePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("usagePolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this config physical i o based on the context it is used
func (m *ConfigPhysicalIO) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePtype(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsagePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConfigPhysicalIO) contextValidatePtype(ctx context.Context, formats strfmt.Registry) error {

	if m.Ptype != nil {
		if err := m.Ptype.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ptype")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ptype")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigPhysicalIO) contextValidateUsage(ctx context.Context, formats strfmt.Registry) error {

	if m.Usage != nil {
		if err := m.Usage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("usage")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("usage")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigPhysicalIO) contextValidateUsagePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.UsagePolicy != nil {
		if err := m.UsagePolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("usagePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("usagePolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConfigPhysicalIO) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConfigPhysicalIO) UnmarshalBinary(b []byte) error {
	var res ConfigPhysicalIO
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
